<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Camargue: Camargue</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Camargue
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Camargue </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the README for Camargue, a TSP solver based on primal cutting plane methods. Camargue tries to move from tour to tour, either proving that a tour is optimal or finding a better one. Camargue was developed in tandem with the research in my master's thesis, "Primal
Cutting Plane Methods for the Traveling Salesman Problem".</p>
<p>To get a sense of the layout of the code, a good starting point would be the documentation for <a class="el" href="class_c_m_r_1_1_solver.html" title="Solution of TSP instances. ">CMR::Solver</a>. To get an idea of how branching machinery is laid out, look at derived classes of <a class="el" href="class_c_m_r_1_1_a_b_c_1_1_base_brancher.html" title="Abstract base class for implementing a branching node selection rule. ">CMR::ABC::BaseBrancher</a>, or the namespace <a class="el" href="namespace_c_m_r_1_1_a_b_c.html" title="Augment-Branch-Cut solution. ">CMR::ABC</a>.</p>
<p>If you wish to browse the source code manually, I have tried to document it in a way that keeps header files compact and readable. Except for class/structure definitions, the documentation in a <code>.hpp</code> is mostly terse one-liners, with detailed coumentation of function parameters and behaviors in the <code>.cpp</code> files.</p>
<p>This page contains information on installing and using Camargue. You can also view the GitHub pages version at</p>
<p><a href="https://cstratopoulos.github.io/camargue/index.html">https://cstratopoulos.github.io/camargue/index.html</a></p>
<p>The text is mostly the same, but you will be able to navigate inline to the Camargue documentation, created with <a href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</a>.</p>
<p>See below for</p>
<ul>
<li><a href="#install">Installation instructions</a></li>
<li><a href="#usage">Usage info</a></li>
</ul>
<h2><a href="#install">Installation</a> </h2>
<p>To get started, you can clone the repository with </p><pre class="fragment">git clone https://github.com/cstratopoulos/camargue.git
</pre><p>For users building the code on one of the UW Unix research servers, from the camargue main directory just do </p><pre class="fragment">cp scripts/Makefile.template.UWlinux Makefile
</pre><p>The compiler and CPLEX directories are already specified, so you just need to do the steps below concerning symlinks to Concorde, and installing externals.</p>
<p>Camargue is a C++11 application, so most importantly you will need a compiler that is compliant with most of the C++11 standard. In fact the code has been developed and tested with GCC 4.7, which technically does <em>not</em> support the C++11 standard in full. Anything after 4.7 or later should be fine, and <code>g++</code> on a Mac (which is actually an alias of Apple <code>clang</code>) should be fine too; this is the preset option. Your compiler is specified by editing the <code>CC</code> definition in the <code>Makefile</code>. A bit more detail and example options are given there.</p>
<p>Camargue relies heavily on two main external dependencies:</p><ul>
<li>The TSP solver/combinatorial optimization library <a href="http://www.math.uwaterloo.ca/tsp/concorde/downloads/downloads.htm">Concorde</a>.</li>
<li>The linear programming solver <a href="http://www-03.ibm.com/software/products/en/ibmilogcpleoptistud">CPLEX 12</a></li>
</ul>
<p>Both must be installed before proceeding. A Concorde installation with CPLEX is best, but it should work with QSOPT too. For help, see</p>
<ul>
<li><a href="http://www.leandro-coelho.com/installing-concorde-tsp-with-cplex-linux/">here</a> for Leandro Coelho's guide to doing an install with CPLEX; and</li>
<li><a href="https://qmha.wordpress.com/2015/08/20/installing-concorde-on-mac-os-x/">here</a> for David S. Johnson's guide to installing on Mac OS X with QSOPT; and</li>
<li>the <a href="http://www.math.uwaterloo.ca/tsp/concorde/DOC/README.html">Concorde README</a>.</li>
</ul>
<p>After installing Concorde, go into the directory <code>camargue/externals</code> and create a symlink to the <code>concorde</code> directory. That is, <code>concorde</code> must point to the folder containing the files <code>TSP</code>, <code>INCLUDE</code>, <code>CUT</code>, etc.</p>
<p>After installing CPLEX, open the <code>Makefile</code> and edit the definitions <code>CPXDIR</code> and <code>CPX_LIB</code>. Details and examples are given in the <code>Makefile</code>.</p>
<p>No further edits to the Makefile should be necessary. After that, you can run the script <code>cmr_install.sh</code> to configure and install Camargue. <code>cmr_install.sh</code> accepts flag arguments to configure the installation to your preferences, and to edit certain other files. Information on individual external dependences is here. The simplest options are <code>-F</code> and <code>-B</code>. So </p><pre class="fragment">./cmr_install.sh -F
</pre><p>will run a <code>F</code>ull install with all the external dependencies. Assuming you are connected to the internet, this will download, extract, and edit all the necessary external dependencies for a full install. This is recommended for best performance, and to observe all the features described in my thesis. The complementary option is </p><pre class="fragment">./cmr_install.sh -B
</pre><p>which runs a <code>B</code>are install with nothing other than Concorde and CPLEX.</p>
<p>In either case, <code>cmr_install.sh</code> will then invoke <code>configure.sh</code> to generate a <code><a class="el" href="config_8hpp.html" title="Configuration macros. ">config.hpp</a></code> file and make appropriate edits to the <code>Makefile</code>. You can double check both of these to see if everything looks right.</p>
<p>If you went with a barebones install and later want to add some or all external enhancements, you should just be able to invoke <code>cmr_install.sh</code> again. For example to add just the safe Gomory code, you would do </p><pre class="fragment">./cmr_install.sh -s
</pre><p>After performing all these steps, you should be able to compile and run Camargue by running <code>make</code> from the main directory, creating the <code>camargue</code> executable.</p>
<p>Additionally, if you like, you can run the unit tests, benchmarks, and experiments that I used to develop Camargue (and write my thesis!) by using the recipe <code>make test</code>. This requires that the Catch unit testing framework be installed, which is done by running <code>cmr_install.sh</code> with the <code>-F</code> full install, or with the flag <code>-c</code>. Install info is here, with specific information on invoking the unit tests here.</p>
<h2><a href="#usage">Usage</a> </h2>
<p>This heading is about standard command line usage of Camargue. For information on running tests/benchmarks, see their documentation.</p>
<p>This section will try to elaborate a bit on the terse documentation that you get from typing <code>./camargue</code> with no arguments.</p>
<p>Camargue accepts problems in two formats: TSPLIB instances with a <code>.tsp</code> suffix, and randomly generated Euclidean instances. If you have a folder called <code>problems</code> in the Camargue directory with TSPLIB instances in it, you can run one with </p><pre class="fragment">./camargue problems/dantzig42.tsp
</pre><p>This will attempt to augment or prove the optimality of a starting tour computed by Concorde's implementation of chained Lin-Kernighan. You can also specify a starting tour with the '-t' flag: </p><pre class="fragment">./camargue problems/dantzig42.tsp -t test_data/tours/dantzig42.sol
</pre><p>will run the solver with the starting tour <code>dantzig42.sol</code>. The format of solution files supported is <em>not</em> the TSPLIB <code>.tour</code> format. Rather, it should be a file whose first line is the instance node count, with the following lines (with arbitrary spacing/indentation) giving zero-indexed ordering of the nodes. If you would like to use a tour in the TSPLIB <code>.tour</code> format, there is a simple script at <code>scripts/to_sol.sh</code> that will convert a <code>.tour</code> file to a <code>.sol</code> file for you.</p>
<p>When loading a starting tour, Camargue will make sure no obvious mistakes are present, checking that no node appears twice and that the indices are drawn from the proper range. You are free to specify an abysmal starting tour, though!</p>
<p>Random problems can be generated with the flag argument <code>-R</code>, and some additional arguments. To generate a 500-node instance on the 1,000 by 1,000 square grid, run </p><pre class="fragment">./camargue -Rn500 -g1000
</pre><p>So <code>-R</code> is the flag, <code>-n</code> specifies node count, and <code>-g</code> specifies the gridsize.</p>
<p>For both styles of problems, Camargue will generate an initial edge set consisting of the nodes in the tour found, plus the union of 10 quick Lin-Kernighan runs as implemented by Concorde's edge generation code. For Euclidean-norm instances, the option <code>-e 1</code> can be used to set the Delaunay triangulation edges as the starting edge set too.</p>
<p>Also for both styles of problems, you can pass a random seed with <code>-s</code>. This is to allow reproducibility through all areas of the code. (Note, however, that if OMP is enabled, non-determinism will still be present.) For a random problem, this will be used to pick the distribution of points on the grid. For both types of problems, it will also always be used in calls to edge generators, separation routines, etc. Negative arguments, or an argument of zero, will result in the current time being used.</p>
<p>By default, Camargue will do a loop of pivoting and cutting for as long as possible, and then begin a so-called Augment-Branch-Cut (ABC) search. The flag option <code>-P</code> will disable branching, attempting a "pure" primal cutting plane solution method instead.</p>
<p>Camargue implements several different node selection rules for guiding the ABC search &ndash; these can be specified by passing options to <code>-b</code>; see the usage info from running <code>./camargue</code> for more info.</p>
<p>The flag option <code>-S</code> is available to specify sparse solution mode. In this mode, Camargue will run no edge pricing of any kind; it will just generate an initial edge set as above and try to prove that a given starting tour is optimal for this edge set. This option is required for the use of primal safe Gomory cut separation, described in the external dependencies.</p>
<p>Moreover, users can also specify cut generation style with <code>-c</code>. Camargue contains implementations of certain primal separation algorithms based on the research of Letchford and Lodi, as well as Fleischer, Letchford and Lodi. The option <code>-c 0</code> will select these algorithms, as well as heuristics for fast blossoms and block combs. The <code>-c 1</code> option, the default, will supplement these with some more exotic standard separation routines implemented in the Concorde TSP solver, such as cut tightening, double deckers, path inequalities, comb teething, and local cuts. Camargue will struggle to solve most instances with the <code>-c 0</code> option, but it can still be used.</p>
<p>Finally, there is the <code>-l [int or float]</code> option to specify a target lower bound for the solver. Since Camargue works by trying to augment starting tours, you may be satisfied with terminating the solver prematurely if some target objective value is met. Values supplied will be rounded up to their integer ceiling, with the interpretation that integer values represent tour lengths and floating points represent dual lower bounds. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
