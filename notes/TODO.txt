change options to getopt_long

just make timer a namespace and profiler have the void print profile
functions
or maybe re-explore timer class and name class for protection now that
i know how static member vars work.............
maybe come up with a generic profiler function that operates on a list of
pairs corresponding to variables and a string for their name, and also somehow
stores an indicator for if we should report percentage/ratio/average
IDEA: have a few vectors, e.g. representing times, cuts, num pivots, something
like that. BUT instead take an initializer list of strings which will
be the lookup key for a map to int or double...or map to int/double
and string where string can be the lookup key for total or average,
etc. 

idea: .....maybe just a CCutils.h file for things we need from
concorde along with wrappers? eg.,
struct CC with sub-structs GH (for gomoryhu), cut for st_cut
(including subtour poly)
learn to call CPXaddrowS for multiple cuts

see edgegen.c and edgegen.h, also tsp_call.c for ideas how to use
concorde to build initial edge set

tooth aggregated coefficients: instead of an ecount length vector, 
create a map of type <Int, Double> mapping edges to their coeff
to be aggregated. With some checking: can call increment/decrement
even if the entries have not yet been initialized; they should
default to zero.

LP PREFS AND ENUM PARAMETERS:
Consider making it so that, e.g., the switching prefs member of the LPprefs
class is implemented as
enum SWITCHING{
     LP::PREFS::SWITCHING::DYNAMIC,
     etc,
     etc
};

and it has a member called switching....

NAMESPACE IDEAS:

PSEP 
     LP
	Prefs, Core, Fixing, Pruning

     DATA
	LP, Best, Graphs, Support

     PureCut
	
     ABC
       BBNode, EdgeStats, Constraints	       	


should store reduced costs obtained from the root node. in branch &
cut, if an augmentation takes place, we can fix edges using reduced
costs from the root and the new best tour opt value as the integrality
gap.


DCMST GOMORY CUTS
generate only those with integer coefficients...could be more
numerically stable and easier to implement?

--

make it so prune cuts calls the more general version but with
intpair(0,0) for skiprange or something like that, to save on
unnecessary copy and pasting

NAIVE BRANCHING
Problem with main branching is it doesn't seem to cut off the fractional 
solution? Notice how naive branching imposes a condition on the partner 
variable which guarantees that the fractional point is cut off. 

L&L say that naive branching allows too many feasible solutions on either side
of the branch (vs main where the current tour is the ONLY feasible solution
on both), but this isn't really a concern when we have an optimal starting
tour, which is often the case

BRANCHING TEMPLATIZATION
Ideal situation: have template classes
      visitor
      constraintmgr
      rightbranch
      edgestats
with function implementations specialized based on an enum class BranchPlan,
which is either main or naive. 

CUT PRUNING
the pruning mechanism of 'tight at current tour' is clearly FAR too lenient,
too many cuts accumulate and augmentation happens rarely (or never), and even
if it does we only prune 10-15 despite having hundreds possibly added

similar to the way concorde tests the age of edges/cuts, maybe record whether
cuts have been tight at a current LP solve, i.e., if we are pivoting to 
a solution where the cuts are tight. maybe test slack at current LP solution
as well, and prune cuts which have not been active for some number of rounds


CALLBACKS
-the cuts generated by mipopt are NOT constraints and as such are NOT
added to the LP after optimization. need a callback to extract the
cuts and add them as constraints, after testing that they are tight at
current node?

-pivot callback: it may be possible to implement simplex pivoting via
 an optimization callback that terminates the simplex optimizer once
 the objective value changes.
