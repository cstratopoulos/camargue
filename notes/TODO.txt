change options to getopt_long

just make timer a namespace and profiler have the void print profile
functions
or maybe re-explore timer class and name class for protection now that
i know how static member vars work.............
maybe come up with a generic profiler function that operates on a list of
pairs corresponding to variables and a string for their name, and also somehow
stores an indicator for if we should report percentage/ratio/average
IDEA: have a few vectors, e.g. representing times, cuts, num pivots, something
like that. BUT instead take an initializer list of strings which will
be the lookup key for a map to int or double...or map to int/double
and string where string can be the lookup key for total or average,
etc. 

make it so that either ABC can take PureCut as a constructor argument,
or ABC has access to purecut.solve() from its interface?

idea: .....maybe just a CCutils.h file for things we need from
concorde along with wrappers? eg.,
struct CC with sub-structs GH (for gomoryhu), cut for st_cut
(including subtour poly)
learn to call CPXaddrowS for multiple cuts

see edgegen.c and edgegen.h, also tsp_call.c for ideas how to use
concorde to build initial edge set

tooth aggregated coefficients: instead of an ecount length vector, 
create a map of type <Int, Double> mapping edges to their coeff
to be aggregated. With some checking: can call increment/decrement
even if the entries have not yet been initialized; they should
default to zero.

LP PREFS AND ENUM PARAMETERS:
Consider making it so that, e.g., the switching prefs member of the LPprefs
class is implemented as
enum SWITCHING{
     LP::PREFS::SWITCHING::DYNAMIC,
     etc,
     etc
};

and it has a member called switching....

NAMESPACE IDEAS:

PSEP 
     LP
	Prefs, Core, Fixing, Pruning

     DATA
	LP, Best, Graphs, Support

     PureCut
	
     ABC
       BBNode, EdgeStats, Constraints	       	


should store reduced costs obtained from the root node. in branch &
cut, if an augmentation takes place, we can fix edges using reduced
costs from the root and the new best tour opt value as the integrality
gap.


DCMST GOMORY CUTS
generate only those with integer coefficients...could be more
numerically stable and easier to implement?

CPLEX GOMORY CUTS
Ideas/functions that could be useful for generating gomory cuts using
CPLEX:

Main idea might be to use CPXchgprobtype to temporarily switch to a
MIP object and then switch back.
    TODO: Do the variables need to be changed to 0-1 as well?

CPXgetnumcuts how many cuts have been added

CPXPARAM_MIP_Limits_GomoryCand - number of candidate variables for
generating cuts....maybe set to one?

CPXmipopt -- apparently the only optimizer that can be called after
changing to MIP problem type

CPX_PARAM_NODELIMIT -- set the maximum number of nodes to zero, at
which point "CPLEX creates cuts and applies heuristics at the root"

CPX_PARAM_CUTSFACTOR -- number of cuts that can be added to the
problem as a ratio to row number of current rows. Could compute the
number precisely that allows one and only one cut to be generated? In
abc.pdf, they say at most 25 cuts are generated

CPX_PARAM_ (parameters affecting cuts) to turn all other cuts off

CPX_PARAM_PREIND (int) to zero to disable presolve entirely

CPX_PARAM_ADVIND (int) 1 default, accepts copybase (which is currently
used). Set to 2, "crushes" an advanced basis supplied by user....maybe
this is what we want??

CPX_PARAM_MIPSEARCH = 1, off so we only use (0 node) branch and cut

CPX_PARAM_STARTALG (int) to CPX_ALG_PRIMAL to set optimization
strategy at root node (the only node)....maybe set primal itlim to
zero?

Turning off heuristics:
CPX_PARAM_RINSHEUR (long) -1
CPX_PARAM_HEURFREQ (long) -1
CPX_PARAM_FPHEUR (int) -1
CPX_PARAM_PROBE (int) -1
