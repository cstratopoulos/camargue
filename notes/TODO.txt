While re-reading and re-editing code, all vector allocations in constructors
should be placed in appropriate try/catch blocks. Should write an operator
bool for each struct that can be tested after initialization. Something like
explicit operator bool() const that returns true if the class is empty or 
if a failure flag was set during construction. These should replace all the
exit(1) statements. 

I think LPfixing should be a derived class of LPCore? Because maybe LPCore
should be called LPManip, hence LPFixing is a type of LPManip...maybe 
LPPrune as well....

Approach: Make the main objects of LPCore protected instead of private, then
	  derived classes can access them.
	  Moreover, add a reference copy constructor to LPCore.
	  Derived classes should be constructed with any additional info they
	  need, plus a reference to LPCore from which they can construct
	  a copy of it. 

Instead of a Cut template, we should have a Cut abstract class: contains 
only virtual methods, all of which must be implemented by derived classes. 
See Wiki article for Virtual function>>abstract classes

In preparation for column generation approach, (and also for portability?)
cut classes should not get the LP itself. They should just store a best cut
or coefficients or something and have CutControl manage the addition of cuts

With blossoms and dominos, it may make sense to store a list/pool of violated
cuts and check those before generating new ones.
Probably shouldn't bother with segments though

maybe come up with a generic profiler function that operates on a list of
pairs corresponding to variables and a string for their name, and also somehow
stores an indicator for if we should report percentage/ratio/average
IDEA: have a few vectors, e.g. representing times, cuts, num pivots, something
like that. BUT instead take an initializer list of strings which will
be the lookup key for a map to int or double...or map to int/double
and string where string can be the lookup key for total or average,
etc. 

idea: .....maybe just a CCutils.h file for things we need from
concorde along with wrappers? eg.,
struct CC with sub-structs GH (for gomoryhu), cut for st_cut
(including subtour poly)
learn to call CPXaddrowS for multiple cuts

tooth aggregated coefficients: instead of an ecount length vector, 
create a map of type <Int, Double> mapping edges to their coeff
to be aggregated. With some checking: can call increment/decrement
even if the entries have not yet been initialized; they should
default to zero.

Light SimpleDP sep is a huge bottleneck at the moment, will probably
have to implement light tooth reduction for it to be viable,
especially since there are some examples where it allows cut
generation to proceed for longer

should store reduced costs obtained from the root node. in branch &
cut, if an augmentation takes place, we can fix edges using reduced
costs from the root and the new best tour opt value as the integrality
gap.


--

NAIVE BRANCHING
Problem with main branching is it doesn't seem to cut off the fractional 
solution? Notice how naive branching imposes a condition on the partner 
variable which guarantees that the fractional point is cut off. 

L&L say that naive branching allows too many feasible solutions on either side
of the branch (vs main where the current tour is the ONLY feasible solution
on both), but this isn't really a concern when we have an optimal starting
tour, which is often the case

BRANCHING TEMPLATIZATION
Ideal situation: have template classes
      visitor
      constraintmgr
      rightbranch
      edgestats
with function implementations specialized based on an enum class BranchPlan,
which is either main or naive. 

CUT PRUNING
the pruning mechanism of 'tight at current tour' is clearly FAR too lenient,
too many cuts accumulate and augmentation happens rarely (or never), and even
if it does we only prune 10-15 despite having hundreds possibly added

similar to the way concorde tests the age of edges/cuts, maybe record whether
cuts have been tight at a current LP solve, i.e., if we are pivoting to 
a solution where the cuts are tight. maybe test slack at current LP solution
as well, and prune cuts which have not been active for some number of
rounds

current approach is sloppy, could use a big overhaul. Ideas:
-now that no_opt/basis refactor works, could be possible to skip
re-optimizing LP

MIP CUT DENSITIES
do some experiments reporting number of nonzeros in segment and
blossom cuts, hence try to determine a reasonable number or ratio
of nonzeros and only terminate CPLEX cutting with a tight,
sufficiently sparse cut
